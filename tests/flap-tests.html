<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tock — Flap Tests</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #111; color: #ccc; font-family: "SF Mono", monospace; padding: 2rem; }
    h1 { font-size: 1rem; margin-bottom: 1rem; color: #e0d8b0; }
    .pass { color: #4a2; }
    .fail { color: #d44; }
    .result { padding: 0.25rem 0; font-size: 0.85rem; }
    #summary { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>flap.js — triggerFlip tests</h1>
  <div id="log"></div>
  <div id="summary"></div>

  <!-- Hidden test fixture — same structure as a flap cell -->
  <div style="display:none">
    <div class="flap-cell" id="test-digit">
      <div class="half top-static"><span>0</span></div>
      <div class="half bottom-static"><span>0</span></div>
      <div class="flap top-flap"><span>0</span></div>
      <div class="flap bottom-flap"><span>0</span></div>
    </div>
  </div>

  <script>
    // ── Minimal test runner ──
    const log = document.getElementById("log");
    let passed = 0, failed = 0;

    function assert(condition, msg) {
      if (!condition) throw new Error(msg);
    }

    function assertEqual(actual, expected, msg) {
      if (actual !== expected) {
        throw new Error(`${msg}: expected "${expected}", got "${actual}"`);
      }
    }

    function test(name, fn) {
      try {
        fn();
        passed++;
        log.innerHTML += `<div class="result pass">✓ ${name}</div>`;
      } catch (e) {
        failed++;
        log.innerHTML += `<div class="result fail">✗ ${name} — ${e.message}</div>`;
      }
    }

    // ── Helpers ──
    const cell = document.getElementById("test-digit");

    function resetCell() {
      delete cell.dataset.flipping;
      cell.classList.remove("flipping");
      cell.querySelector(".top-static span").textContent = "0";
      cell.querySelector(".bottom-static span").textContent = "0";
      cell.querySelector(".top-flap span").textContent = "0";
      cell.querySelector(".bottom-flap span").textContent = "0";
      cell.querySelector(".top-flap").style.transform = "";
      cell.querySelector(".bottom-flap").style.transform = "";
    }

    function fireAnimationEnd() {
      cell.querySelector(".bottom-flap").dispatchEvent(new Event("animationend"));
    }

    function layers() {
      return {
        topStatic:    cell.querySelector(".top-static span").textContent,
        bottomStatic: cell.querySelector(".bottom-static span").textContent,
        topFlap:      cell.querySelector(".top-flap span").textContent,
        bottomFlap:   cell.querySelector(".bottom-flap span").textContent,
      };
    }
  </script>

  <!-- Load flap.js (init() exits early — no #clock element) -->
  <script src="../flap.js"></script>

  <script>
    // ── createFlapCell ──

    test("createFlapCell returns a .flap-cell element", () => {
      const cell = createFlapCell();
      assert(cell instanceof HTMLElement, "should return an element");
      assert(cell.classList.contains("flap-cell"), "should have .flap-cell class");
    });

    test("createFlapCell has four layers with spans", () => {
      const cell = createFlapCell();
      assert(cell.querySelector(".top-static span"), "missing top-static span");
      assert(cell.querySelector(".bottom-static span"), "missing bottom-static span");
      assert(cell.querySelector(".top-flap span"), "missing top-flap span");
      assert(cell.querySelector(".bottom-flap span"), "missing bottom-flap span");
    });

    test("createFlapCell layers start with en-dash", () => {
      const cell = createFlapCell();
      assertEqual(cell.querySelector(".top-static span").textContent, "\u2013", "top-static");
      assertEqual(cell.querySelector(".bottom-static span").textContent, "\u2013", "bottom-static");
      assertEqual(cell.querySelector(".top-flap span").textContent, "\u2013", "top-flap");
      assertEqual(cell.querySelector(".bottom-flap span").textContent, "\u2013", "bottom-flap");
    });

    // ── triggerFlip layer setup ──

    test("sets top-static to new char", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assertEqual(layers().topStatic, "1", "top-static");
    });

    test("sets top-flap to old char (the card that falls)", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assertEqual(layers().topFlap, "0", "top-flap");
    });

    test("sets bottom-flap to new char (the card that lands)", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assertEqual(layers().bottomFlap, "1", "bottom-flap");
    });

    test("keeps bottom-static as old char during flip", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assertEqual(layers().bottomStatic, "0", "bottom-static");
    });

    test("adds .flipping class", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assert(cell.classList.contains("flipping"), "missing .flipping class");
    });

    // ── per-cell flip guard ──

    test("blocks concurrent flips on same cell", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      triggerFlip(cell, "1", "2"); // should be ignored
      assertEqual(layers().topStatic, "1", "top-static unchanged by second call");
      assertEqual(layers().topFlap, "0", "top-flap unchanged by second call");
    });

    test("sets data-flipping during flip", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assertEqual(cell.dataset.flipping, "true", "data-flipping");
    });

    // ── animationend cleanup ──

    test("updates bottom-static to new char on animationend", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      fireAnimationEnd();
      assertEqual(layers().bottomStatic, "1", "bottom-static");
    });

    test("removes .flipping class on animationend", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      fireAnimationEnd();
      assert(!cell.classList.contains("flipping"), ".flipping should be removed");
    });

    test("clears inline transform on top-flap", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      cell.querySelector(".top-flap").style.transform = "rotateX(-90deg)";
      fireAnimationEnd();
      assertEqual(cell.querySelector(".top-flap").style.transform, "", "top-flap transform");
    });

    test("clears inline transform on bottom-flap", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      cell.querySelector(".bottom-flap").style.transform = "rotateX(0deg)";
      fireAnimationEnd();
      assertEqual(cell.querySelector(".bottom-flap").style.transform, "", "bottom-flap transform");
    });

    test("syncs top-flap to new char (ready for next flip)", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      fireAnimationEnd();
      assertEqual(layers().topFlap, "1", "top-flap");
    });

    test("clears data-flipping after animationend", () => {
      resetCell();
      triggerFlip(cell, "0", "1");
      assertEqual(cell.dataset.flipping, "true", "should be set during flip");
      fireAnimationEnd();
      assert(cell.dataset.flipping === undefined, "should be cleared after animationend");
    });

    // ── Sequential flips ──

    test("chains multiple flips correctly", () => {
      resetCell();
      triggerFlip(cell, "0", "1"); fireAnimationEnd();
      triggerFlip(cell, "1", "2"); fireAnimationEnd();
      triggerFlip(cell, "2", "3"); fireAnimationEnd();
      const l = layers();
      assertEqual(l.topStatic, "3", "topStatic");
      assertEqual(l.bottomStatic, "3", "bottomStatic");
      assertEqual(l.topFlap, "3", "topFlap");
    });

    test("handles 9 → 0 wrap-around", () => {
      resetCell();
      triggerFlip(cell, "9", "0"); fireAnimationEnd();
      assertEqual(layers().topStatic, "0", "topStatic");
      assertEqual(layers().bottomStatic, "0", "bottomStatic");
    });

    // ── Summary ──
    const total = passed + failed;
    const summary = document.getElementById("summary");
    summary.className = failed ? "fail" : "pass";
    summary.textContent = `${passed}/${total} passed` + (failed ? ` — ${failed} failed` : "");
  </script>
</body>
</html>
