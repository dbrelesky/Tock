<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tock — Cascade Tests</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #111; color: #ccc; font-family: "SF Mono", monospace; padding: 2rem; }
    h1 { font-size: 1rem; margin-bottom: 1rem; color: #e0d8b0; }
    h2 { font-size: 0.85rem; margin-top: 1rem; margin-bottom: 0.5rem; color: #888; }
    .pass { color: #4a2; }
    .fail { color: #d44; }
    .result { padding: 0.25rem 0; font-size: 0.85rem; }
    #summary { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>flap.js — cascade tests</h1>
  <div id="log"></div>
  <div id="summary"></div>

  <!-- Hidden test fixtures -->
  <div style="display:none">
    <div class="clock" id="test-clock">
      <div class="clock-digits"></div>
    </div>
    <div class="clock" id="test-clock-2">
      <div class="clock-digits"></div>
    </div>
  </div>

  <script>
    // ── Minimal test runner (supports async tests) ──
    const log = document.getElementById("log");
    let passed = 0, failed = 0, pending = 0;

    function assert(condition, msg) {
      if (!condition) throw new Error(msg);
    }

    function assertEqual(actual, expected, msg) {
      if (actual !== expected) {
        throw new Error(`${msg}: expected "${expected}", got "${actual}"`);
      }
    }

    function logResult(name, pass, errMsg) {
      if (pass) {
        passed++;
        log.innerHTML += `<div class="result pass">✓ ${name}</div>`;
      } else {
        failed++;
        log.innerHTML += `<div class="result fail">✗ ${name} — ${errMsg}</div>`;
      }
      pending--;
      if (pending === 0) showSummary();
    }

    function test(name, fn) {
      pending++;
      try {
        const result = fn();
        if (result && typeof result.then === "function") {
          // Async test
          result.then(() => logResult(name, true))
                .catch(e => logResult(name, false, e.message));
        } else {
          logResult(name, true);
        }
      } catch (e) {
        logResult(name, false, e.message);
      }
    }

    function section(name) {
      log.innerHTML += `<h2>${name}</h2>`;
    }

    function showSummary() {
      const total = passed + failed;
      const summary = document.getElementById("summary");
      summary.className = failed ? "fail" : "pass";
      summary.textContent = `${passed}/${total} passed` + (failed ? ` — ${failed} failed` : "");
    }

    // ── Helpers ──
    function freshClock(id, showSeconds) {
      const clockEl = document.getElementById(id);
      return renderClock(clockEl, showSeconds);
    }

    function fireAnimationEndOnAll(cells) {
      for (const cell of cells) {
        cell.querySelector(".bottom-flap").dispatchEvent(new Event("animationend"));
      }
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  </script>

  <!-- Load flap.js (init() exits early — no #clock element) -->
  <script src="../flap.js"></script>

  <script>
    const testDigits = ["1", "2", "3", "0", "4", "5"];
    const testPeriod = "PM";

    // ── powerOnCascade basics ──
    section("powerOnCascade basics");

    test("returns a Promise", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      const result = powerOnCascade(cells, periodEl, testDigits, testPeriod, 0);
      assert(result && typeof result.then === "function", "should return a Promise");
      // Wait for setTimeout(fn, 0) callbacks to fire before dispatching animationend
      return delay(0).then(() => {
        fireAnimationEndOnAll(cells);
        return result;
      });
    });

    test("sets period label immediately", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      const p = powerOnCascade(cells, periodEl, testDigits, "AM", 0);
      assertEqual(periodEl.textContent, "AM", "period label");
      // Wait for setTimeout(fn, 0) callbacks before cleanup
      return delay(0).then(() => {
        fireAnimationEndOnAll(cells);
        return p;
      });
    });

    test("cells start with en-dash before cascade", () => {
      const { cells } = freshClock("test-clock", true);
      for (let i = 0; i < cells.length; i++) {
        assertEqual(cells[i].querySelector(".top-static span").textContent, "\u2013", `cell[${i}]`);
      }
    });

    test("after cascade + animationend, all cells show correct digits", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      // staggerMs=0 so all fire after setTimeout(fn, 0)
      const p = powerOnCascade(cells, periodEl, testDigits, testPeriod, 0);
      return delay(0).then(() => {
        fireAnimationEndOnAll(cells);
        return p;
      }).then(() => {
        for (let i = 0; i < cells.length; i++) {
          assertEqual(
            cells[i].querySelector(".top-static span").textContent,
            testDigits[i],
            `cell[${i}] top-static`
          );
          assertEqual(
            cells[i].querySelector(".bottom-static span").textContent,
            testDigits[i],
            `cell[${i}] bottom-static`
          );
        }
      });
    });

    test("triggers triggerFlip on each cell (data-flipping set)", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      const p = powerOnCascade(cells, periodEl, testDigits, testPeriod, 0);
      // Wait for setTimeout(fn, 0) callbacks so triggerFlip has been called
      return delay(0).then(() => {
        for (let i = 0; i < cells.length; i++) {
          assertEqual(cells[i].dataset.flipping, "true", `cell[${i}] data-flipping`);
        }
        fireAnimationEndOnAll(cells);
        return p;
      });
    });

    // ── Stagger behavior ──
    section("stagger behavior");

    test("first cell flips immediately, last cell is staggered", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      const p = powerOnCascade(cells, periodEl, testDigits, testPeriod, 50);

      // Wait for setTimeout(fn, 0) so the first cell's callback fires
      return delay(0).then(() => {
        // First cell should be flipping (setTimeout 0*50 = 0)
        assertEqual(cells[0].dataset.flipping, "true", "first cell flipping");

        // Last cell should NOT be flipping yet (setTimeout 250ms for 6 cells)
        assert(cells[5].dataset.flipping !== "true", "last cell should not be flipping yet");

        // Wait for all stagger timeouts then fire animationend
        return delay(300);
      }).then(() => {
        fireAnimationEndOnAll(cells);
        return p;
      });
    });

    test("all cells flipping after stagger completes", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      powerOnCascade(cells, periodEl, testDigits, testPeriod, 20);

      // Wait for all staggers to fire (6 * 20ms = 120ms, add buffer)
      return delay(200).then(() => {
        for (let i = 0; i < cells.length; i++) {
          // Cell should be flipping or already finished
          assert(
            cells[i].dataset.flipping === "true" || cells[i].querySelector(".top-static span").textContent === testDigits[i],
            `cell[${i}] should have been triggered`
          );
        }
        fireAnimationEndOnAll(cells);
      });
    });

    // ── Promise resolution ──
    section("promise resolution");

    test("promise resolves after last cell animationend", () => {
      const { cells, periodEl } = freshClock("test-clock", true);
      let resolved = false;

      const p = powerOnCascade(cells, periodEl, testDigits, testPeriod, 0);
      p.then(() => { resolved = true; });

      // Wait for setTimeout(fn, 0) callbacks so triggerFlip has attached listeners
      return delay(0).then(() => {
        // Fire animationend on all cells except the last
        for (let i = 0; i < cells.length - 1; i++) {
          cells[i].querySelector(".bottom-flap").dispatchEvent(new Event("animationend"));
        }

        return delay(0);
      }).then(() => {
        assert(!resolved, "should not resolve before last cell animationend");

        // Now fire last cell
        cells[cells.length - 1].querySelector(".bottom-flap").dispatchEvent(new Event("animationend"));

        return delay(0);
      }).then(() => {
        assert(resolved, "should resolve after last cell animationend");
      });
    });

    // ── startTickLoop with initialDigits ──
    section("startTickLoop with initialDigits");

    test("first tick does not overwrite digits when initialDigits provided", () => {
      const { cells, periodEl } = freshClock("test-clock-2", true);
      // Pre-set cells to known values (simulating cascade already ran)
      setAllDigits(cells, testDigits);
      periodEl.textContent = testPeriod;

      // Start tick loop with initialDigits
      startTickLoop(cells, periodEl, "America/New_York", true, testDigits);

      // Cells should still show the test digits (not overwritten by setAllDigits)
      // Since time may have changed by 1 second, just verify no instant overwrite happened
      // by checking that cells aren't showing en-dash
      for (let i = 0; i < cells.length; i++) {
        assert(
          cells[i].querySelector(".top-static span").textContent !== "\u2013",
          `cell[${i}] should not be reset to en-dash`
        );
      }
    });

    test("first tick without initialDigits calls setAllDigits", () => {
      const { cells, periodEl } = freshClock("test-clock-2", true);
      // Cells start as en-dash from renderClock

      startTickLoop(cells, periodEl, "America/New_York", true);

      // First tick should have set real digits (not en-dash)
      for (let i = 0; i < cells.length; i++) {
        assert(
          cells[i].querySelector(".top-static span").textContent !== "\u2013",
          `cell[${i}] should show real digit, not en-dash`
        );
      }
    });
  </script>
</body>
</html>
